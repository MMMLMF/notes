### 关于自然语言处理方面的笔记

#### 计算相似度的方法
度量文本相似度包括如下三种方法：

一是基于关键词匹配的传统方法，如N-gram相似度；

二是将文本映射到向量空间，再利用余弦相似度等方法；

三是深度学习的方法，如基于用户点击数据的深度学习语义匹配模型DSSM，基于卷积神经网络的ConvNet，以及目前state-of-art的Siamese LSTM等方法。 

1) 字面距离

> 莱文斯坦距离(编辑距离)、Jaro距离、SimHash

2) 语义相似性

①基于关键词匹配
> N-gram 相似度\
> Jaccard 相似度

② 基于向量空间
> Word2vec\
> TF-IDF\
> LSA\
> 相似度计算：欧式距离、曼哈顿距离、余弦相似度、其他

③基于深度学习
> 深度学习\
> DSSM\
> ConvNet\
> Skip-thoughts Vectors\
> Tree-LSTM\
> Siamese LSTM/Manhattan LSTM/MaLSTM\
> Others


### 算法的提出

一个算法的提出，一定是先有场景和需求，或者是前面的算法有改进的空间。场景高于算法这点是毋庸置疑的。

### 特征工程

#### 词袋模型

词袋模型的基本思想是将文本符号化，将一段文本表示成一堆符号的集合；由于中文文本的多样性，通常导致构建的词袋维数较大，仅仅以词为单位（Unigram）构建的词袋可能就达到几万维，如果考虑二元词组（Bigram）、三元词组（Trigram）的话词袋大小可能会有几十万之多，因此基于词袋模型的特征表示通常是极其稀疏的。

几种不同的表示方法：

第1种：Naive版本，不考虑词出现的频率，只要出现过就在相应的位置标1，否则为0；

第2种：考虑词频（即term frequency），认为一段文本中出现越多的词越重要，因此权重也越大；

第3种：考虑词的重要性，以TFIDF表征一个词的重要程度。TFIDF反映了一种折中的思想：即在一篇文档中，TF认为一个词出现的次数越大可能越重要（但也可能并不是，比如停用词：“的”“是”之类的）；IDF认为一个词出现在的文档数越少越重要（但也可能不是，比如一些无意义的生僻词）。

通常情况下采用第3种方法。文本中所出现的词的重要程度是不太一样的，比如上面的例子中“我”，“喜欢”，“学习”这3个词就要比其他词更为重要。除了TFIDF的表征方法，还有chi-square，互信息（MI），熵等其他一些衡量词重要性的指标（见这里）。

经验总结：

通常考虑unigram和bigram来构建词袋模型（trigram维数太高，取得的gain也不高）；

用TFIDF时，注意对TF作归一化，通常用词频除以文本的长度；

如果构建的词袋维数太高，可以用TF（或者TFIDF）来卡，将一些不常见的词（会有很多噪音词，如联系方式、邮箱之类的）过滤掉；

如果有一些先验的词袋，word count通常都是比较强的一维特征（比如情感分类中，正负情感词的出现次数），可以考虑；

基于词袋模型构建的特征通常高维但稀疏，通常使用非线性模型取得的效果较线性的要好，推荐大家尝试使用一些基于决策树的boosting模型，如GBDT；这也很好理解，较线性模型而言，非线性模型能够学习出更加复杂的规则，对于文本而言，体现在能够一定程度上考虑词出现的语境（context）情况，比如，对于识别文本是否为骂人语料，文本中出现“妈”，同时也出现“你”，那么为骂人的概率会增大。

词袋模型比较简单直观，它通常能学习出一些关键词和类别之间的映射关系，但是缺点也很明显：

丢失了文本中词出现的先后顺序信息；

仅将词语符号化，没有考虑词之间的语义联系（比如，“麦克风”和“话筒”是不同的词，但是语义是相同的）；

#### embedding

word2vec的原理很简单，基本思想是用词出现的上下文来表示这个词，上下文越接近的词之间的语义相似性越高。例如，上一小节中举到的例子，“话筒”和“麦克风”两者的上下文可能非常接近，因此会被认为是语义接近的。（不过语义接近并不代表含义接近，例如“黑色”和“白色”的上下文是相似的，但所代表的含义可能却是相反的）。

目前做word embedding的方法很多，比较流行的有两种：word2vec、GloVe

word2vec和GloVe两者的思想是类似的，都是用词的上下文来表示这个词，但是用的方法不同：word2vec是predict-based，用一个3层的NN模型来预测词的上下文（或者反过来），词向量是训练过程的中间产物；而GloVe则是count-based的方法，通过对共现词矩阵做降维来获取词的向量。两者在效果上相差不大，但GloVe模型的优势在于矩阵运算可以并行化，这样训练速度能加快。具体两者的差别可以看[论文](http://clic.cimec.unitn.it/marco/publications/acl2014/baroni-etal-countpredict-acl2014.pdf)。

有了word embedding之后，我们怎么得到文本的embedding呢？

对于短文本而言，比较好的方法有：

(1) 取短文本的各个词向量之和（或者取平均）作为文本的向量表示；

(2) 用一个pre-train好的NN model得到文本作为输入的最后一层向量表示；

除此之外，还有TwitterLda，TwitterLda是Lda的简化版本，针对短文本做主题刻画，实际效果也还不错。

基于embedding的特征刻画的是语义、主题层面上的特征，较词匹配而言，有一定的泛化能力。

#### NN model

NN的好处在于能end2end实现模型的训练和测试，利用模型的非线性和众多参数来学习特征，而不需要手工提取特征。

CNN和RNN都是NLP中常用的模型，两个模型捕捉特征的角度也不太一样，CNN善于捕捉文本中关键的局部信息，而RNN则善于捕捉文本的上下文信息（考虑语序信息），并且有一定的记忆能力，两者都可以用在文本分类任务中，而且效果都不错。

对于简单的文本分类任务，用几个简单的NN模型基本就够了（调参数也是一大累活儿）。

最后我们可以将这些NNs预测的分值作为我们分类系统的一个特征，来加强分类系统的性能。

#### 任务本身

通过我们对数据的观察和感知，也许能够发现一些可能有用的特征。有时候，这些手工特征对最后的分类效果提升很大。举个例子，比如对于正负面评论分类任务，对于负面评论，包含负面词的数量就是一维很强的特征。

这部分的特征设计就是在拼脑力和拼经验，建议可以多看看各个类别数据找找感觉，将那些你直观上感觉对分类有帮助的东西设计成特征，有时候这些经验主义的东西很有用（可能是模型从数据学习不出来的）。

#### 特征融合

在设计完这些特征之后，怎么融合更合适呢？对于特征维数较高、数据模式复杂的情况，建议用非线性模型（如比较流行的GDBT, XGBoost）；对于特征维数较低、数据模式简单的情况，建议用简单的线性模型即可（如LR）。

模型融合能够从多个角度更加全面地学习出训练数据中的模式，往往能比单个模型效果好一点（2~3个点左右）。

另外，通过观察LR模型给各个特征分配的权重大小和正负，我们可以看出对于训练数据而言，这些特征影响分类的重要程度（权重大小（绝对值）），以及特征影响最终分类目标的极性。特别的，我们可以通过观察那些手工特征的权重来验证这些特征的有效性和有效程度。




这几个博客[佟学强](http://www.cnblogs.com/txq157)、[红色石头](https://blog.csdn.net/red_stone1/)、[科学空间](https://spaces.ac.cn/)、[liuchongee](https://blog.csdn.net/liuchonge)、[Jey Zhang](http://www.jeyzhang.com/)、[西士城](https://zhuanlan.zhihu.com/xitucheng10)、[机器学习算法与自然语言处理](https://zhuanlan.zhihu.com/qinlibo-ml)、[悟乙己](https://blog.csdn.net/sinat_26917383/article/details/54882554)、[wildml](http://www.wildml.com/)很不错
